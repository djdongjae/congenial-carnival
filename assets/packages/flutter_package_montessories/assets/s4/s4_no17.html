<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.5, user-scalable=no">
    <title>몬테소리 콘텐츠</title>
    <style>
        svg {
            /*border: 1px solid #000;*/
            display: block;
            margin: 5px auto;
            cursor: crosshair;
            width: 630px;
            height: 630px;
        }
    </style>
</head>

<body>

    <svg id="paintSvg" data-name="paintSvg" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="100 270 400 380">
        <!-- Generator: Adobe Illustrator 29.3.0, SVG Export Plug-In . SVG Version: 2.1.0 Build 146)  -->
        <defs>
            <style>
                .st0 {
                    fill: #add1d0;
                }

                .st1 {
                    fill: #efeeed;
                }

                .st2 {
                    fill: #231815;
                }

                .st3 {
                    fill: #fff;
                    stroke: #b1d3cf;
                    stroke-miterlimit: 10;
                    stroke-width: 2.09px;
                }
            </style>
        </defs>
        <!-- 마스킹 그룹 -->
        <defs>
            <clipPath id="clipPath1">
                <use id="clipRef1" href="#fillArea1" />
            </clipPath>
        </defs>
        <g>
            <rect class="st0" x="113.06" y="270.94" width="359.01" height="291.31" />
            <rect class="st1" x="113.06" y="349.68" width="359.01" height="291.31" />
        </g>
        <g>
            <path class="st2" d="M281.75,311.49c-3.84.99-9.37,1.35-13.02,1.35h-2.99v-14.16h3.9v10.69c4.12,0,7.89-.33,11.51-1.19l.6,3.3ZM268.63,327.96v-11.91h19.28v11.91h-19.28ZM283.98,319.21h-11.45v5.54h11.45v-5.54ZM287.91,307.1v7.26h-3.93v-17.29h3.93v6.67h4.25v3.37h-4.25Z" />
            <path class="st2" d="M317.06,298.16c0,4.06-.35,8.22-.94,11.32h4.37v3.27h-26.92v-3.27h18.84c.44-2.18.75-6.11.72-8.09h-16.1v-3.23h20.03ZM317.06,316.9v11.49h-3.9v-8.25h-16.32v-3.23h20.22Z" />
        </g>
        <path id="fillArea1" class="st3" onmousedown="onclickPath(1)" ontouchstart="onclickPath(1)" d="M149.42,436.44s0-8.64,3.96,0,4.32,12.23,14.03,14.03,8.28,6.48,15.11,10.08,13.67,3.24,19.43,7.56,7.56-1.44,14.75-2.52,9,1.8,12.59-2.52,6.84-2.49,7.92-5.92-3.6-2.09,0-6,.36-22.98,1.8-24.78,8.64-2.16,7.56-7.2,0-6.12,5.04-5.04,10.44-8.64,14.75-6.12,11.51,4.68,18.71,5.4,11.15-5.4,16.19,1.8,12.95,8.64,17.27,5.76,6.12-1.08,10.44-.36,6.12,4.68,7.2,7.56,6.48,3.6,10.44,2.88,6.84-1.8,11.87.36,9.36,7.2,15.11,4.32c5.76-2.88,6.84,9,7.56,10.44s6.84,14.39,10.08,16.19,2.88,3.89,1.44,7.34-.36,12.09,3.24,12.81,5.76,5.04,11.15,6.12c5.4,1.08,8.64-2.16,9.36,2.16s5.04,10.8,4.32,11.87-1.08,10.8,2.88,11.87,3.24,4.68,2.52,8.64,3.6,8.64-2.16,12.59-3.96,9.36-2.88,11.15-1.8,9-3.24,10.08-6.12,3.24-1.08,6.12-5.04,2.52-5.04,4.32,0,5.04-1.8,5.4-4.68,2.52-2.52,6.48-1.8.36-2.16,3.6,1.08,3.6-5.76,4.32-9,2.52-7.92,5.04-.36,6.12-1.8,6.12-4.32-1.44-7.56-2.16-13.31-.36-17.63,2.16-5.76,1.08-10.44,0-16.19-1.44-20.87-1.44-10.08-8.64-8.28-13.67-.72-11.15-.72-15.11-3.6-4.68-6.84-3.6-10.08,1.44-13.67,0-11.15-7.56-17.63-4.32-11.15,1.44-13.31,1.44-7.92,3.6-11.87,2.88-9.72-3.24-12.95-2.52-4.68-1.44-9.36-3.96-5.04-2.16-9-2.52-15.11-4.32-15.11-8.64-5.4-15.83-5.4-15.83c0,0-6.12-.36-1.08-5.76s-3.24-7.2-9-5.76-15.83-1.08-11.51-5.4c4.32-4.32,2.88-12.23,2.88-18.71s-1.08-12.95-.36-14.75-8.28-2.16-10.44-1.08-11.15-3.96-7.92-8.64,8.64-1.08,3.24-4.68-11.15-3.21-15.47-9.16-10.44-7.75-10.08-20.71Z" />
        <!-- 사용자가 그리는 영역 (마스킹 적용) -->
        <g id="drawingGroup1" clip-path="url(#clipPath1)"></g>
    </svg>


    <script>
        const svg = document.getElementById("paintSvg");
        let clipRef = document.getElementById("clipRef1");
        let drawingGroup = document.getElementById("drawingGroup1"); // 초기 그리기 그룹은 첫 번째 영역
        let fillArea = document.getElementById("fillArea1");
        let drawing = false;
        let currentPath = null;
        let callFlutter = false;
		
		// 확대/축소 변수
        let scale = 1;
        let lastDistance = 0;
        let currentX = 0, currentY = 0; // 드래그 위치
        let isDragging = false;

        // 영역 클릭 시 해당 영역으로 전환
        function onclickPath(id) {
            fillArea = document.getElementById(`fillArea${id}`);

            if (!fillArea) return;

            drawingGroup = document.getElementById(`drawingGroup${id}`);
        }

        // SVG 좌표 변환 함수
        function getSVGCoords(event) {
            const point = svg.createSVGPoint();
            let x, y;

            if (event.touches) {
                x = event.touches[0].clientX;
                y = event.touches[0].clientY;
            } else {
                x = event.clientX;
                y = event.clientY;
            }

            point.x = x;
            point.y = y;
            return point.matrixTransform(svg.getScreenCTM().inverse());
        }

        // 경로 내부 점인지 확인하는 함수
        function isInsidePath(x, y) {
            const point = svg.createSVGPoint();
            point.x = x;
            point.y = y;
            return fillArea.isPointInFill(point);
        }

        // 그리기 시작 함수
        function startDrawing(e) {
            e.preventDefault();
            const {
                x,
                y
            } = getSVGCoords(e);
            if (!isInsidePath(x, y)) return;

            drawing = true;
            currentPath = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
            currentPath.setAttribute("stroke", "lightgray");
            currentPath.setAttribute("stroke-width", "10");
            currentPath.setAttribute("fill", "none");
            currentPath.setAttribute("stroke-linecap", "round");
            currentPath.setAttribute("points", `${x},${y}`);
            drawingGroup.appendChild(currentPath);

            resetDrawTimer();
        }

        // 그리기 이동 함수
        function moveDrawing(e) {
            if (!drawing) return;
            e.preventDefault();

            const {
                x,
                y
            } = getSVGCoords(e);
            if (!isInsidePath(x, y)) return;

            let points = currentPath.getAttribute("points");
            points += ` ${x},${y}`;
            currentPath.setAttribute("points", points);
        }

        // 그리기 종료 함수
        function stopDrawing() {
            drawing = false;
        }

        // Flutter 호출 함수
        function resetDrawTimer() {
            if (!callFlutter) {
                console.log(callFlutter);
                callFlutter = true;
                window.drawCanvas.postMessage(JSON.stringify({
                    data: 'draw'
                }));
            }
        }
		
		// 줌 처리 함수
        function handleZoom(e) {
            if (e.touches.length === 2) {
                let dx = e.touches[0].clientX - e.touches[1].clientX;
                let dy = e.touches[0].clientY - e.touches[1].clientY;
                let distance = Math.sqrt(dx * dx + dy * dy);
    
                if (lastDistance !== 0) {
                    let delta = distance - lastDistance;
                    scale += delta * 0.005; // 줌 속도
                    scale = Math.max(1.0, Math.min(2.5, scale)); // 줌 한계 (0.5배 ~ 3배)
                    svg.setAttribute("style", `transform: scale(${scale})`);
                }
    
                lastDistance = distance; // 마지막 거리 업데이트
                e.preventDefault(); // 기본 동작(스크롤 등)을 막음
            }
        }
    
        // 첫 번째 터치 시 초기화
        function handleTouchStart(e) {
            if (e.touches.length === 2) {
                let dx = e.touches[0].clientX - e.touches[1].clientX;
                let dy = e.touches[0].clientY - e.touches[1].clientY;
                lastDistance = Math.sqrt(dx * dx + dy * dy); // 초기 거리 계산
            }
        }
    
        // 터치 끝날 때
        function handleTouchEnd(e) {
            if (e.touches.length < 2) {
                lastDistance = 0; // 두 손가락이 하나로 떨어지면 초기화
            }
        }
    
        // 드래그 이동 함수
        function handleMouseDown(e) {
            isDragging = true;
            currentX = e.clientX;
            currentY = e.clientY;
            svg.style.cursor = 'grabbing';
        }
    
        function handleMouseMove(e) {
            if (!isDragging) return;
    
            const dx = e.clientX - currentX;
            const dy = e.clientY - currentY;
            currentX = e.clientX;
            currentY = e.clientY;
    
            const transform = svg.getAttribute('transform') || 'translate(0, 0)';
            const regex = /translate\((-?\d+), (-?\d+)\)/;
            const match = transform.match(regex);
    
            const newX = (match ? parseInt(match[1]) : 0) + dx;
            const newY = (match ? parseInt(match[2]) : 0) + dy;
            svg.setAttribute('transform', `translate(${newX}, ${newY})`);
        }
    
        function handleMouseUp() {
            isDragging = false;
            svg.style.cursor = 'grab';
        }
    
        function handleMouseLeave() {
            isDragging = false;
            svg.style.cursor = 'grab';
        }

        // 마우스 이벤트 리스너
        svg.addEventListener("mousedown", startDrawing);
        svg.addEventListener("mousemove", moveDrawing);
        svg.addEventListener("mouseup", stopDrawing);
        svg.addEventListener("mouseleave", stopDrawing);

        // 터치 이벤트 리스너
        svg.addEventListener("touchstart", function (e) {
            if (e.touches.length === 1) {
                startDrawing(e); // 한 손가락으로 그리기 시작
            } else if (e.touches.length === 2) {
                handleTouchStart(e); // 두 손가락 줌 시작
            }
        });
    
        svg.addEventListener("touchmove", function (e) {
            if (e.touches.length === 1) {
                moveDrawing(e); // 한 손가락으로 그리기 이동
            } else if (e.touches.length === 2) {
                handleZoom(e); // 두 손가락 줌 처리
            }
        });
    
        svg.addEventListener("touchend", function (e) {
            stopDrawing(); // 그리기 종료
            handleTouchEnd(e); // 두 손가락 처리 종료
        });
    </script>
</body>

</html>